# CFDL Engine Design Document

## Overview

This document outlines the architecture and implementation plan for the CFDL Engine, which processes Intermediate Representation (IR) files generated by the Java compilation pipeline to produce cash flow analyses, financial metrics, and distribution waterfalls.

## Architecture Principles

### Monte Carlo as Orchestrator
The engine is designed with Monte Carlo simulation as the primary orchestrating framework, supporting both:
- **Deterministic execution**: Single trial with fixed parameters
- **Stochastic execution**: Multiple trials with parameter variation

### Hierarchical Processing
Data flows through the system at multiple hierarchy levels:
```
Deal â†’ Asset â†’ Component â†’ Stream â†’ Cash Flow Entries
```

### Extensible Design
Architecture supports future enhancements:
- State modeling and transitions
- Event-driven processing
- Real options (dynamic model modification)
- Advanced stochastic processes

## Implementation Language: Julia

**Rationale**: Based on research showing 300x+ performance improvements in financial applications, Julia provides:
- Native mathematical computing performance
- Rich ecosystem for optimization and time-series analysis
- Parallel computing capabilities for Monte Carlo
- Standalone binary deployment capabilities

## Component Architecture

### 2.1 Monte Carlo Harness âœ… COMPLETED
**Purpose**: Orchestrate trial execution and manage stochastic variables

**Implementation Status**: Complete with 31 passing tests

**Key Features Implemented**:
- âœ… **Monte Carlo Orchestration**: Supports both deterministic (1 trial) and stochastic (N trials) execution
- âœ… **Stochastic Parameter Sampling**: Handles Normal, Uniform, LogNormal distributions and Random Walk processes
- âœ… **Seed Management**: Reproducible results with unique seeds per trial
- âœ… **IR JSON Loading**: Flexible parsing of compilation pipeline output
- âœ… **Comprehensive Testing**: Full unit test coverage with robust error handling

**Stochastic Variable Types**:
- **Fixed**: `rent_growth = 3%`
- **Distribution Sampling**: `rent_growth ~ Normal(3%, 1%)` (sample once per trial)
- **Random Walk**: `rent_growth[t] = rent_growth[t-1] + Normal(0%, 0.5%)` (evolves over time)

**Performance**: 100 trials in ~0.027 seconds with memory-efficient implementation

**Input**: IR JSON + stochastic parameter definitions
**Output**: Trial controller that executes downstream pipeline

### 2.2 Temporal Grid Generator âœ… COMPLETED
**Purpose**: Create time period structure for cash flow allocation

**Implementation Status**: Complete with 67 passing tests

**Key Features Implemented**:
- âœ… **Multi-Frequency Support**: Daily, weekly, monthly, quarterly, annual period generation
- âœ… **Business Day Conventions**: Following, preceding, modified-following, and none
- âœ… **Holiday Calendars**: US federal holidays, UK bank holidays, and none/target
- âœ… **Day Count Conventions**: Actual/365, Actual/360, 30/360, Actual/Actual
- âœ… **Date Parsing**: Flexible parsing of multiple date formats
- âœ… **Period Utilities**: Find periods by date, get overlapping periods
- âœ… **Comprehensive Testing**: Edge case coverage with business day accuracy

**Business Day Handling**:
- **Weekend Detection**: Automatic Saturday/Sunday exclusion
- **Holiday Recognition**: US federal holidays (New Year's, Independence Day, Christmas, etc.)
- **Convention Application**: Adjusts dates to valid business days

**Performance**: Supports 10,000+ periods with safety limits and memory efficiency

**Input**: Deal calendar configuration from IR
**Output**: Temporal grid array with period definitions and metadata

### 2.3 Stream Allocator & Logic Block Engine âœ… COMPLETED
**Purpose**: Allocate stream cash flows to time periods with custom logic execution

**Implementation Status**: Complete with comprehensive testing and demo integration

**Key Features Implemented**:
- âœ… **Stream Processing**: Allocates cash flows from IR streams across all temporal periods
- âœ… **Growth Factor Application**: Supports fixed rates, distribution sampling, and compound growth
- âœ… **Deterministic Behavior**: Uses distribution means for deterministic trials (1 trial mode)
- âœ… **Logic Block Framework**: Infrastructure ready for custom Julia/Python code execution
- âœ… **Category Tracking**: Separates Revenue vs Expense streams with proper aggregation
- âœ… **Period-by-Period Allocation**: Creates detailed cash flow entries with line items
- âœ… **Integration**: Seamlessly works with Monte Carlo harness and temporal grid

**Growth Factor Types**:
- **Fixed Growth**: `growth: { type: "fixed", rate: 0.025 }` â†’ 2.5% compound annually
- **Distribution Growth**: `growth: { type: "distribution", distribution: { type: "Normal", mean: 0.03, std: 0.01 } }`
- **Expression Growth**: Framework ready for custom expressions (future)
- **Random Walk Growth**: Framework ready for time-varying rates (future)

**Logic Block Integration**:
- âœ… **Framework Ready**: Infrastructure for executing custom Julia/Python code snippets
- âœ… **Context Creation**: Access to current model state and sampled variables  
- âœ… **Override Capability**: Ability to modify stream values during allocation
- ðŸ”„ **Future Enhancement**: Real options triggering (asset modifications)

**Real Options Examples** (Framework Ready):
- "If occupancy hits 100% â†’ add 3 floors to building" (asset modification)
- "If oil price < $50 â†’ switch extraction strategy" (component behavior change)
- "If interest rates > 6% â†’ refinance" (deal structure change)

**Performance**: Allocates 120 stream entries (2 streams Ã— 60 periods) in ~0.001 seconds

**Demo Integration**: 
- Shows $22M+ total allocations across 5-year period
- Revenue: $16.3M, Expenses: $5.7M with proper growth application
- Period-by-period breakdown with growth factor visualization

**Input**: Stream definitions from IR + temporal grid + sampled variables
**Output**: Period-by-period allocated cash flows per stream with metadata

### 2.4 Hierarchical Cash-Flow Aggregator
**Purpose**: Multi-view aggregation with drill-down capability

**Cash Flow Views**:
- **Monthly View**: Detailed period-by-period flows
- **Annual View**: Aggregated annual cash flow statements
- **Hierarchical Drill-down**: Deal â†’ Asset â†’ Component â†’ Stream traceability

**Key Features**:
- Revenue aggregation with source entity tracking
- Unlevered and levered cash flow series
- View tag filtering (GAAP, Forecast, etc.)
- Multi-dimensional result structure

**Output Format**: Conforms to `ontology/result/cash-flow.schema.yaml`

### 2.5 Metrics Library
**Purpose**: Calculate standard financial metrics from cash flow results

**Supported Metrics**:
- NPV (Net Present Value)
- IRR (Internal Rate of Return)  
- DSCR (Debt Service Coverage Ratio)
- MOIC (Multiple on Invested Capital)
- Payback Period
- eNPV (Expected NPV)
- eIRR (Expected IRR)

**Key Features**:
- Metrics at multiple hierarchy levels (deal, asset, component)
- Period and annualized rate support
- Stochastic metric distributions
- Schema compliance with `ontology/result/metrics/`

### 2.6 Waterfall Distributor
**Purpose**: Apply tiered distribution logic to available cash

**Key Features**:
- Sequential tier processing
- Condition evaluation (boolean expressions, preferred rates)
- Explicit splits vs capital-stack inheritance
- State tracking for future extensions

**Input**: Cash flow results + waterfall definitions from IR
**Output**: Period-by-period participant distributions

## Execution Flow

### Per-Trial Execution
```julia
function execute_trial(trial_id, ir_data, stochastic_params)
    # 1. Sample stochastic variables for this trial
    seed = generate_seed(trial_id)
    sampled_vars = sample_variables(seed, stochastic_params)
    
    # 2. Generate temporal structure
    grid = generate_temporal_grid(ir_data.calendar, sampled_vars)
    
    # 3. Allocate streams with logic blocks
    allocated_streams = allocate_streams(
        ir_data.streams, 
        grid, 
        sampled_vars, 
        ir_data.logic_blocks
    )
    
    # 4. Aggregate hierarchical cash flows
    cash_flows = aggregate_cash_flows(allocated_streams, grid)
    
    # 5. Calculate financial metrics  
    metrics = calculate_metrics(cash_flows, ir_data.assumptions)
    
    # 6. Execute waterfall distributions
    distributions = execute_waterfall(cash_flows, ir_data.waterfall)
    
    # 7. Package trial result with seed traceability
    return TrialResult(trial_id, seed, cash_flows, metrics, distributions)
end
```

### Monte Carlo Controller
```julia
function run_monte_carlo(ir_file_path, num_trials=1)
    ir_data = load_ir(ir_file_path)
    
    if num_trials == 1
        # Deterministic execution
        result = execute_trial(1, ir_data, nothing)
        return [result]
    else
        # Stochastic execution with parallel trials
        return parallel_map(1:num_trials) do trial_id
            execute_trial(trial_id, ir_data, ir_data.stochastic_params)
        end
    end
end
```

## Input/Output Specifications

### Input: IR JSON Format
Generated by Java compilation pipeline, containing:
- Deal/Asset/Component/Stream definitions
- Calendar and temporal configuration
- Logic block definitions
- Waterfall specifications  
- Stochastic parameter definitions
- Schema metadata

### Output: Results JSON
Conforming to CFDL result schemas:
- `ontology/result/cash-flow.schema.yaml`
- `ontology/result/metrics/*.schema.yaml`  
- `ontology/result/waterfall.schema.yaml`

## Development Approach

### Implementation Sequence
1. **Monte Carlo Harness**: Trial orchestration framework
2. **Temporal Grid Generator**: Time period structure foundation
3. **Stream Allocator**: Cash flow allocation with logic blocks
4. **Cash-Flow Aggregator**: Multi-view hierarchical aggregation
5. **Metrics Library**: Financial calculations
6. **Waterfall Distributor**: Distribution logic

### Testing Strategy
- Unit tests for each component with comprehensive edge cases
- Integration tests for end-to-end pipeline
- Performance benchmarks against reference implementations
- Validation using example CFDL files

### Deployment
- Standalone Julia binary compiled using `juliac`
- CLI interface: `cfdl-engine <ir-file> [--trials N] [--output results.json]`
- Integration with existing Java pipeline via file I/O

## Future Extensions

### State Modeling
- Deal/asset/component state tracking
- State transition logic in logic blocks
- State-dependent cash flow generation

### Event Processing  
- Event-driven time points in temporal grid
- Trigger-based logic block execution
- External event integration

### Real Options
- Dynamic model modification during execution
- Condition-based asset/component changes
- Option valuation and exercise logic

### Advanced Stochastic Processes
- Correlated variable sampling
- Regime-switching models
- Jump-diffusion processes
- Copula-based dependency modeling

---

*This document represents the current design as of Task 2 implementation. Updates will be made as development progresses.*